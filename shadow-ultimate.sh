#!/bin/bash
# SHADOW ULTIMATE - Script tout-en-un pour Raspberry Pi 4/5
# Installation compl√®te, r√©paration, optimisation et VS Code
# Auteur: Alexandre
# Date: $(date +"%Y-%m-%d")

set -euo pipefail

# Gestion d'erreur globale
trap 'log_err "Erreur ligne $LINENO. Continuez manuellement ou relancez le script."; exit 1' ERR

# Fonction pour ex√©cuter des commandes sans faire √©chouer le script
safe_run() {
  if "$@"; then
    return 0
  else
    log_warn "Commande √©chou√©e: $*"
    return 1
  fi
}

# ========== CONFIGURATION & UI ==========
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; CYAN='\033[0;36m'; MAGENTA='\033[0;35m'; NC='\033[0m'

log_header() { echo -e "\n${MAGENTA}=== $* ===${NC}"; }
log_info()   { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok()     { echo -e "${GREEN}[‚úì]${NC} $*"; }
log_warn()   { echo -e "${YELLOW}[‚ö†]${NC} $*"; }
log_err()    { echo -e "${RED}[‚úó]${NC} $*"; }
log_action() { echo -e "${CYAN}[‚Üí]${NC} $*"; }

require_root() {
  if [[ $EUID -ne 0 ]]; then
    log_err "Ce script doit √™tre ex√©cut√© avec sudo"
    echo "Usage: sudo bash $0"
    exit 1
  fi
  if [[ -z "${SUDO_USER:-}" ]]; then
    log_err "Variable SUDO_USER non d√©finie. Utilisez: sudo bash $0"
    exit 1
  fi
}

get_user_home() { getent passwd "$SUDO_USER" | cut -d: -f6; }

# ========== DIAGNOSTIC SYST√àME ==========
system_analysis() {
  log_header "ANALYSE DU SYST√àME"
  
  local issues=0
  local user_home=$(get_user_home)
  
  # Architecture
  local arch=$(uname -m)
  if [[ "$arch" =~ ^(aarch64|arm64)$ ]]; then
    log_ok "Architecture ARM64 d√©tect√©e"
  else
    log_warn "Architecture non ARM64: $arch (peut ne pas fonctionner)"
    ((issues++))
  fi
  
  # Raspberry Pi
  if grep -qi "raspberry" /proc/device-tree/model 2>/dev/null; then
    local model=$(cat /proc/device-tree/model | tr -d '\0')
    log_ok "Raspberry Pi d√©tect√©: $model"
  else
    log_warn "Syst√®me non Raspberry Pi"
    ((issues++))
  fi
  
  # OS Version
  if command -v lsb_release >/dev/null 2>&1; then
    local os_info=$(lsb_release -ds 2>/dev/null || echo "Inconnu")
    log_ok "OS: $os_info"
  fi
  
  # √âtat Shadow
  local shadow_status="‚ùå Non install√©"
  if command -v shadow-prod >/dev/null 2>&1; then
    shadow_status="‚úÖ shadow-prod install√©"
  elif command -v shadow-beta >/dev/null 2>&1; then
    shadow_status="‚úÖ shadow-beta install√©"
  elif command -v shadow >/dev/null 2>&1; then
    shadow_status="‚úÖ shadow install√©"
  else
    ((issues++))
  fi
  echo "Shadow: $shadow_status"
  
  # ShadowUSB
  local shadowusb_status="‚ùå Non install√©"
  if dpkg -s shadowusb >/dev/null 2>&1; then
    local status=$(dpkg -s shadowusb 2>/dev/null | awk -F': ' '/^Status:/{print $2}')
    if echo "$status" | grep -q 'installed.*ok.*installed'; then
      shadowusb_status="‚úÖ Install√© et configur√©"
    elif echo "$status" | grep -q 'deinstall.*ok.*config-files'; then
      shadowusb_status="‚ö†Ô∏è Partiellement d√©sinstall√© (sera r√©par√©)"
      ((issues++))
    elif echo "$status" | grep -q 'half-configured\|unpacked'; then
      shadowusb_status="‚ö†Ô∏è Installation incompl√®te (sera r√©par√©)"
      ((issues++))
    else
      shadowusb_status="‚ö†Ô∏è Probl√®me de statut ($status)"
      ((issues++))
    fi
  else
    ((issues++))
  fi
  echo "ShadowUSB: $shadowusb_status"
  
  # VS Code
  local vscode_status="‚ùå Non install√©"
  if command -v code >/dev/null 2>&1; then
    vscode_status="‚úÖ Install√©"
  else
    ((issues++))
  fi
  echo "VS Code: $vscode_status"
  
  # Services syst√®me
  log_info "V√©rification des services critiques..."
  local services=("dbus")
  for service in "${services[@]}"; do
    if systemctl is-active --quiet "$service"; then
      log_ok "$service: actif"
    else
      log_warn "$service: inactif"
      ((issues++))
    fi
  done
  
  # Notifications
  local notif_status="‚ùå Non configur√©"
  if command -v dunst >/dev/null 2>&1 || command -v notification-daemon >/dev/null 2>&1; then
    if pgrep -f "dunst|notification-daemon" >/dev/null 2>&1; then
      notif_status="‚úÖ Actif"
    else
      notif_status="‚ö†Ô∏è Install√© mais inactif"
      ((issues++))
    fi
  else
    ((issues++))
  fi
  echo "Notifications: $notif_status"
  
  # Permissions utilisateur
  local groups=$(groups "$SUDO_USER" 2>/dev/null || echo "")
  local missing_groups=()
  for group in input plugdev video audio; do
    if ! echo "$groups" | grep -q "\b$group\b"; then
      missing_groups+=("$group")
    fi
  done
  if [ ${#missing_groups[@]} -eq 0 ]; then
    log_ok "Groupes utilisateur: OK"
  else
    log_warn "Groupes manquants: ${missing_groups[*]}"
    ((issues++))
  fi
  
  echo
  if [ $issues -eq 0 ]; then
    log_ok "Syst√®me parfaitement configur√© ! üéâ"
    return 0
  else
    log_warn "$issues probl√®me(s) d√©tect√©(s). Correction automatique..."
    return $issues
  fi
}

# ========== MISE √Ä JOUR SYST√àME ==========
system_update() {
  log_header "MISE √Ä JOUR DU SYST√àME"
  
  log_action "Mise √† jour de la liste des paquets..."
  safe_run apt update -qq
  
  log_action "Mise √† jour du syst√®me..."
  safe_run apt full-upgrade -y || apt upgrade -y || true
  
  log_action "Installation des d√©pendances de base..."
  
  # Liste des paquets essentiels (avec alternatives pour compatibilit√©)
  local essential_packages=(
    "wget" "curl" "gpg" "git" "apt-transport-https"
    "xdg-desktop-portal-gtk" "xdg-desktop-portal" 
    "notification-daemon" "libnotify-bin" "dbus-x11"
    "dunst" "at-spi2-core"
  )
  
  # Paquets avec alternatives
  local optional_packages=(
    "software-properties-common"  # Peut √™tre absent sur certaines versions
    "libva2" "libvdpau1" "libva-drm2" "libva-wayland2" "libdrm2"
    "libasound2" "libpulse0"
  )
  
  # Installation des paquets essentiels
  for pkg in "${essential_packages[@]}"; do
    if ! apt install -y "$pkg" 2>/dev/null; then
      log_warn "Impossible d'installer $pkg, on continue..."
    fi
  done
  
  # Installation des paquets optionnels (sans faire √©chouer le script)
  for pkg in "${optional_packages[@]}"; do
    apt install -y "$pkg" 2>/dev/null || {
      log_warn "Paquet $pkg non disponible, recherche d'alternatives..."
      case "$pkg" in
        "libasound2") apt install -y libasound2t64 2>/dev/null || true ;;
        "software-properties-common") 
          apt install -y python3-software-properties 2>/dev/null || true ;;
      esac
    }
  done
  
  log_ok "Syst√®me mis √† jour et d√©pendances install√©es"
}

# ========== CONFIGURATION RASPBERRY PI ==========
configure_raspberry_pi() {
  log_header "CONFIGURATION RASPBERRY PI"
  
  # D√©tection du chemin config.txt
  local config_path="/boot/config.txt"
  if [ -f "/boot/firmware/config.txt" ]; then
    config_path="/boot/firmware/config.txt"
  fi
  
  log_action "Configuration boot ($config_path)..."
  
  # Pi 5 - Kernel 4K pages (obligatoire pour Shadow)
  if grep -qi "raspberry pi 5" /proc/device-tree/model 2>/dev/null; then
    log_action "Configuration sp√©cifique Raspberry Pi 5..."
    if ! grep -q "^\[pi5\]" "$config_path"; then
      echo -e "\n[pi5]\nkernel=kernel8.img" >> "$config_path"
      log_warn "Kernel 4K pages activ√© - RED√âMARRAGE REQUIS"
    elif ! grep -A5 "^\[pi5\]" "$config_path" | grep -q "kernel=kernel8.img"; then
      sed -i '/^\[pi5\]/a kernel=kernel8.img' "$config_path"
      log_warn "Kernel 4K pages activ√© - RED√âMARRAGE REQUIS"
    else
      log_ok "Kernel 4K pages d√©j√† activ√©"
    fi
  fi
  
  # Optimisations g√©n√©rales
  local optimizations=(
    "gpu_mem=128"
    "disable_overscan=1"
    "hdmi_force_hotplug=1"
    "hdmi_drive=2"
  )
  
  for opt in "${optimizations[@]}"; do
    if ! grep -q "^$opt" "$config_path"; then
      echo "$opt" >> "$config_path"
      log_action "Ajout√©: $opt"
    fi
  done
  
  log_ok "Configuration Raspberry Pi termin√©e"
}

# ========== INSTALLATION SHADOW ==========
install_shadow() {
  log_header "INSTALLATION SHADOW PC"
  
  # V√©rification si d√©j√† install√©
  if command -v shadow-prod >/dev/null 2>&1 || command -v shadow-beta >/dev/null 2>&1; then
    log_ok "Shadow d√©j√† install√©"
    return 0
  fi
  
  log_action "T√©l√©chargement et installation de Shadow..."
  
  # Nettoyage des anciennes sources
  rm -f /etc/apt/sources.list.d/shadow*.list /etc/apt/sources.list.d/shadow*.sources
  
  # Installation via le .deb officiel
  local tmpdir="/tmp/shadow-ultimate"
  mkdir -p "$tmpdir"
  cd "$tmpdir"
  
  local deb_url="https://update.shadow.tech/launcher/prod/linux/rpi/shadow-arm64.deb"
  if wget -q --show-progress -O shadow-arm64.deb "$deb_url"; then
    log_action "Installation du paquet Shadow..."
    apt install -y ./shadow-arm64.deb || {
      log_warn "Installation .deb √©chou√©e, ajout manuel du d√©p√¥t..."
      # Ajout manuel du d√©p√¥t
      wget -qO- http://repository.shadow.tech/shadow_signing.key | gpg --dearmor > /etc/apt/trusted.gpg.d/shadow.gpg
      echo 'deb [arch=arm64] http://repository.shadow.tech/prod bullseye main' > /etc/apt/sources.list.d/shadow-prod.list
      apt update
      apt install -y shadow-prod
    }
  else
    log_err "√âchec du t√©l√©chargement, installation manuelle du d√©p√¥t..."
    wget -qO- http://repository.shadow.tech/shadow_signing.key | gpg --dearmor > /etc/apt/trusted.gpg.d/shadow.gpg
    echo 'deb [arch=arm64] http://repository.shadow.tech/prod bullseye main' > /etc/apt/sources.list.d/shadow-prod.list
    apt update
    apt install -y shadow-prod
  fi
  
  cd /
  rm -rf "$tmpdir"
  log_ok "Shadow PC install√©"
}

# ========== INSTALLATION SHADOWUSB ==========
install_shadowusb() {
  log_header "INSTALLATION SHADOWUSB"
  
  # V√©rifier l'√©tat actuel
  local current_status=""
  if dpkg -s shadowusb >/dev/null 2>&1; then
    current_status=$(dpkg -s shadowusb 2>/dev/null | awk -F': ' '/^Status:/{print $2}')
    log_info "√âtat actuel ShadowUSB: $current_status"
  fi
  
  # Si partiellement d√©sinstall√© ou en erreur, nettoyer compl√®tement
  if echo "$current_status" | grep -qE 'deinstall|half-configured|unpacked'; then
    log_action "Nettoyage complet de l'installation pr√©c√©dente..."
    dpkg --remove --force-remove-reinstreq shadowusb 2>/dev/null || true
    apt purge -y shadowusb 2>/dev/null || true
    apt autoremove -y 2>/dev/null || true
    rm -rf /usr/share/shadowusb /usr/lib/shadowusb /opt/shadowusb 2>/dev/null || true
    rm -f /var/lib/dpkg/info/shadowusb.* 2>/dev/null || true
  fi
  
  log_action "Installation de ShadowUSB..."
  
  # S'assurer que le d√©p√¥t Shadow est pr√©sent
  if ! apt-cache policy | grep -q "repository.shadow.tech"; then
    log_action "Ajout du d√©p√¥t Shadow..."
    wget -qO- http://repository.shadow.tech/shadow_signing.key 2>/dev/null | gpg --dearmor > /etc/apt/trusted.gpg.d/shadow.gpg 2>/dev/null || true
    echo 'deb [arch=arm64] http://repository.shadow.tech/prod bullseye main' > /etc/apt/sources.list.d/shadow-prod.list
    apt update -qq 2>/dev/null || apt update
  fi
  
  # Pr√©parer l'environnement AVANT l'installation pour √©viter les erreurs postinst
  prepare_shadowusb_environment
  
  # Installation avec gestion d'erreur
  log_action "T√©l√©chargement de ShadowUSB..."
  if ! apt install -y shadowusb 2>&1 | tee /tmp/shadowusb-install.log; then
    log_warn "Installation √©chou√©e, tentative de correction automatique..."
    
    # Extraire le paquet sans configurer
    apt download shadowusb 2>/dev/null || true
    if [ -f shadowusb_*.deb ]; then
      log_action "Installation manuelle du paquet..."
      dpkg --unpack shadowusb_*.deb 2>/dev/null || true
      rm shadowusb_*.deb
    fi
    
    # Pr√©parer l'environnement et reconfigurer
    prepare_shadowusb_environment
    fix_shadowusb_postinst
    dpkg --configure shadowusb 2>/dev/null || true
    apt --fix-broken install -y 2>/dev/null || true
  fi
  
  # V√©rification finale et r√©paration si n√©cessaire
  if ! dpkg -s shadowusb 2>/dev/null | grep -q "Status: install ok installed"; then
    log_action "R√©paration finale de ShadowUSB..."
    fix_shadowusb_postinst
  fi
  
  # Activation du service
  systemctl enable shadowusb.service 2>/dev/null || true
  systemctl daemon-reload 2>/dev/null || true
  
  # V√©rification finale
  if systemctl is-enabled shadowusb.service >/dev/null 2>&1; then
    log_ok "ShadowUSB install√© et configur√© avec succ√®s"
  else
    log_warn "ShadowUSB install√© mais service non activ√© (peut n√©cessiter un red√©marrage)"
  fi
}

# Pr√©pare l'environnement pour √©viter les erreurs postinst de shadowusb
prepare_shadowusb_environment() {
  log_action "Pr√©paration de l'environnement ShadowUSB..."
  
  # Cr√©er tous les r√©pertoires possibles que le postinst pourrait chercher
  local base_dirs=(
    "/usr/share/shadowusb"
    "/usr/lib/shadowusb"
    "/opt/shadowusb"
  )
  
  for base_dir in "${base_dirs[@]}"; do
    if [ -d "$base_dir" ] || [ ! -d "$base_dir" ]; then
      mkdir -p "$base_dir"/{system,udev,bin,scripts,lib} 2>/dev/null || true
      touch "$base_dir"/{system,udev}/.keep 2>/dev/null || true
      
      # Cr√©er des liens symboliques si n√©cessaire
      for subdir in system udev; do
        if [ ! -d "$base_dir/$subdir" ]; then
          mkdir -p "$base_dir/$subdir"
        fi
      done
    fi
  done
  
  # Cr√©er le groupe shadow-users s'il n'existe pas
  if ! getent group shadow-users >/dev/null 2>&1; then
    groupadd -r shadow-users 2>/dev/null || true
  fi
  
  # Ajouter l'utilisateur au groupe
  if ! groups "$SUDO_USER" 2>/dev/null | grep -q shadow-users; then
    usermod -a -G shadow-users "$SUDO_USER" 2>/dev/null || true
  fi
  
  log_ok "Environnement pr√©par√©"
}

fix_shadowusb_postinst() {
  log_action "R√©paration intelligente du postinst ShadowUSB..."
  
  local postinst="/var/lib/dpkg/info/shadowusb.postinst"
  
  # Si le postinst n'existe pas, rien √† faire
  if [ ! -f "$postinst" ]; then
    log_warn "Postinst ShadowUSB introuvable, tentative de r√©installation..."
    apt download shadowusb 2>/dev/null && dpkg --unpack shadowusb_*.deb 2>/dev/null && rm shadowusb_*.deb 2>/dev/null || true
    if [ ! -f "$postinst" ]; then
      log_warn "Impossible de r√©parer (postinst manquant)"
      return 1
    fi
  fi
  
  chmod +x "$postinst" 2>/dev/null || true
  
  # Trouver le r√©pertoire de base de ShadowUSB
  local base_dir=""
  local possible_dirs=(
    "/usr/share/shadowusb"
    "/usr/lib/shadowusb"
    "/opt/shadowusb"
  )
  
  # Chercher d'abord dans les fichiers install√©s
  if dpkg -L shadowusb >/dev/null 2>&1; then
    base_dir=$(dpkg -L shadowusb 2>/dev/null | grep -E "shadowusb/(system|udev|bin)" | head -1 | xargs dirname 2>/dev/null || echo "")
  fi
  
  # Si non trouv√©, prendre le premier r√©pertoire existant
  if [ -z "$base_dir" ] || [ ! -d "$base_dir" ]; then
    for dir in "${possible_dirs[@]}"; do
      if [ -d "$dir" ]; then
        base_dir="$dir"
        break
      fi
    done
  fi
  
  # Cr√©er le r√©pertoire si n√©cessaire
  if [ -z "$base_dir" ] || [ ! -d "$base_dir" ]; then
    base_dir="/usr/share/shadowusb"
    mkdir -p "$base_dir"
  fi
  
  log_action "R√©pertoire de base: $base_dir"
  
  # Cr√©er TOUS les r√©pertoires que le postinst pourrait chercher
  local required_dirs=("system" "udev" "bin" "scripts" "lib" "config" "data")
  for subdir in "${required_dirs[@]}"; do
    mkdir -p "$base_dir/$subdir" 2>/dev/null || true
    touch "$base_dir/$subdir/.keep" 2>/dev/null || true
  done
  
  # Cr√©er des r√©pertoires relatifs au r√©pertoire courant (au cas o√π le postinst utilise ./)
  mkdir -p ./system ./udev ./bin 2>/dev/null || true
  
  # Analyse du postinst pour comprendre ses besoins
  log_action "Analyse du script postinst..."
  if grep -q "systemctl" "$postinst" 2>/dev/null; then
    log_info "Le postinst utilise systemctl"
  fi
  
  # Cr√©er le groupe shadow-users si n√©cessaire
  if ! getent group shadow-users >/dev/null 2>&1; then
    groupadd -r shadow-users 2>/dev/null || true
  fi
  
  # Ajouter l'utilisateur au groupe
  if ! groups "$SUDO_USER" 2>/dev/null | grep -q shadow-users; then
    usermod -a -G shadow-users "$SUDO_USER" 2>/dev/null || true
    log_ok "Utilisateur $SUDO_USER ajout√© au groupe shadow-users"
  fi
  
  # M√©thode 1: Ex√©cuter dans le r√©pertoire de base
  log_action "Tentative 1: Ex√©cution dans $base_dir..."
  if (cd "$base_dir" && "$postinst" configure 2>&1 | grep -v "Directory.*does not exist" || true); then
    log_ok "Postinst ex√©cut√© avec succ√®s (m√©thode 1)"
  else
    # M√©thode 2: Cr√©er des liens symboliques
    log_action "Tentative 2: Cr√©ation de liens symboliques..."
    ln -sf "$base_dir/system" ./system 2>/dev/null || true
    ln -sf "$base_dir/udev" ./udev 2>/dev/null || true
    
    if "$postinst" configure 2>/dev/null; then
      log_ok "Postinst ex√©cut√© avec succ√®s (m√©thode 2)"
    else
      # M√©thode 3: Patcher le postinst pour ignorer les erreurs
      log_action "Tentative 3: Patch du postinst..."
      local postinst_backup="${postinst}.backup"
      cp "$postinst" "$postinst_backup" 2>/dev/null || true
      
      # Ajouter 'set +e' au d√©but pour continuer malgr√© les erreurs
      sed -i '1 a\set +e' "$postinst" 2>/dev/null || true
      sed -i 's/exit 1/exit 0/g' "$postinst" 2>/dev/null || true
      
      if "$postinst" configure 2>/dev/null; then
        log_ok "Postinst ex√©cut√© avec succ√®s (m√©thode 3 - patch√©)"
      else
        log_warn "Toutes les tentatives ont √©chou√©, configuration forc√©e..."
      fi
      
      # Restaurer le postinst original
      if [ -f "$postinst_backup" ]; then
        mv "$postinst_backup" "$postinst" 2>/dev/null || true
      fi
    fi
  fi
  
  # Nettoyer les liens symboliques temporaires
  rm -f ./system ./udev ./bin 2>/dev/null || true
  
  # Forcer la configuration finale
  log_action "Configuration finale de dpkg..."
  dpkg --configure shadowusb 2>/dev/null || dpkg --configure --force-all shadowusb 2>/dev/null || true
  dpkg --configure -a 2>/dev/null || true
  
  # V√©rifier le statut final
  local final_status=$(dpkg -s shadowusb 2>/dev/null | awk -F': ' '/^Status:/{print $2}' || echo "unknown")
  if echo "$final_status" | grep -q "install ok installed"; then
    log_ok "‚úÖ ShadowUSB correctement configur√©"
    return 0
  elif echo "$final_status" | grep -q "install ok"; then
    log_warn "‚ö†Ô∏è ShadowUSB install√© mais avec avertissements"
    return 0
  else
    log_warn "‚ö†Ô∏è ShadowUSB partiellement configur√© (statut: $final_status)"
    return 1
  fi
}

# ========== INSTALLATION VS CODE ==========
install_vscode() {
  log_header "INSTALLATION VS CODE"
  
  if command -v code >/dev/null 2>&1; then
    log_ok "VS Code d√©j√† install√©"
    return 0
  fi
  
  log_action "Installation de VS Code..."
  
  # Ajout du d√©p√¥t Microsoft
  wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > /etc/apt/trusted.gpg.d/packages.microsoft.gpg
  echo "deb [arch=arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main" > /etc/apt/sources.list.d/vscode.list
  
  apt update
  apt install -y code
  
  log_ok "VS Code install√©"
  
  # Extensions utiles pour le d√©veloppement
  log_action "Installation d'extensions VS Code utiles..."
  local user_home=$(get_user_home)
  sudo -u "$SUDO_USER" code --install-extension ms-vscode.cpptools || true
  sudo -u "$SUDO_USER" code --install-extension ms-python.python || true
  sudo -u "$SUDO_USER" code --install-extension ms-vscode.vscode-typescript-next || true
  sudo -u "$SUDO_USER" code --install-extension esbenp.prettier-vscode || true
  
  log_ok "Extensions VS Code install√©es"
}

# ========== CONFIGURATION NOTIFICATIONS ==========
setup_notifications() {
  log_header "CONFIGURATION DES NOTIFICATIONS"
  
  local user_home=$(get_user_home)
  local systemd_user_dir="$user_home/.config/systemd/user"
  
  log_action "Configuration des services de notification..."
  
  # Cr√©ation du r√©pertoire systemd user
  mkdir -p "$systemd_user_dir"
  
  # Service dunst
  cat > "$systemd_user_dir/dunst.service" <<'EOF'
[Unit]
Description=Dunst notification daemon
Documentation=man:dunst(1)
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.Notifications
ExecStart=/usr/bin/dunst
Restart=on-failure

[Install]
WantedBy=default.target
EOF

  # Service D-Bus global
  cat > /usr/share/dbus-1/services/org.freedesktop.Notifications.service <<'EOF'
[D-BUS Service]
Name=org.freedesktop.Notifications
Exec=/usr/bin/dunst
SystemdService=dunst.service
EOF

  # Autostart
  local autostart_dir="$user_home/.config/autostart"
  mkdir -p "$autostart_dir"
  cat > "$autostart_dir/shadow-notifications.desktop" <<'EOF'
[Desktop Entry]
Type=Application
Name=Shadow Notifications
Exec=sh -c 'sleep 3 && dunst'
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
StartupNotify=false
EOF

  chown -R "$SUDO_USER:$SUDO_USER" "$user_home/.config"
  
  log_ok "Notifications configur√©es"
}

# ========== CONFIGURATION ENVIRONNEMENT ==========
setup_environment() {
  log_header "CONFIGURATION DE L'ENVIRONNEMENT"
  
  local user_home=$(get_user_home)
  
  log_action "Configuration des variables d'environnement..."
  
  # Variables globales
  cat > /etc/environment <<'EOF'
LIBVA_DRIVER_NAME=v4l2_request
LIBVA_V4L2_REQUEST_VIDEO_PATH=/dev/video10,/dev/video11,/dev/video12
SDL_VIDEODRIVER=wayland
EOF

  # Configuration utilisateur
  cat > "$user_home/.xsessionrc" <<'EOF'
# Configuration Shadow
export XDG_CURRENT_DESKTOP=${XDG_CURRENT_DESKTOP:-LXDE}
export XDG_SESSION_TYPE=${XDG_SESSION_TYPE:-x11}
export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u)/bus"

# D√©marrage D-Bus si n√©cessaire
if [ ! -S "/run/user/$(id -u)/bus" ]; then
  eval "$(dbus-launch --sh-syntax --exit-with-session)"
fi

# D√©marrage des notifications
if ! pgrep -f "dunst|notification-daemon" >/dev/null 2>&1; then
  (dunst >/dev/null 2>&1 &)
fi

# Acc√©l√©ration mat√©rielle
export LIBVA_DRIVER_NAME=v4l2_request
export LIBVA_V4L2_REQUEST_VIDEO_PATH=/dev/video10,/dev/video11,/dev/video12
EOF

  # .profile
  if ! grep -q "XDG_CURRENT_DESKTOP" "$user_home/.profile" 2>/dev/null; then
    cat >> "$user_home/.profile" <<'EOF'

# Configuration Shadow
export XDG_CURRENT_DESKTOP=${XDG_CURRENT_DESKTOP:-LXDE}
export XDG_SESSION_TYPE=${XDG_SESSION_TYPE:-x11}
if [ -z "$DBUS_SESSION_BUS_ADDRESS" ] && [ "$XDG_SESSION_TYPE" = "x11" ]; then
  export $(dbus-launch) 2>/dev/null
fi
EOF
  fi
  
  chown "$SUDO_USER:$SUDO_USER" "$user_home/.xsessionrc" "$user_home/.profile"
  
  log_ok "Environnement configur√©"
}

# ========== OPTIMISATIONS SYST√àME ==========
system_optimizations() {
  log_header "OPTIMISATIONS SYST√àME"
  
  log_action "Optimisations r√©seau..."
  cat > /etc/sysctl.d/99-shadow.conf <<'EOF'
# Optimisations Shadow
net.core.rmem_default = 262144
net.core.rmem_max = 16777216
net.core.wmem_default = 262144
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 262144 16777216
net.ipv4.tcp_wmem = 4096 262144 16777216
net.core.netdev_max_backlog = 5000
vm.swappiness = 10
EOF
  sysctl -p /etc/sysctl.d/99-shadow.conf >/dev/null
  
  log_action "Configuration des groupes utilisateur..."
  usermod -a -G input,plugdev,video,audio "$SUDO_USER" || true
  
  log_ok "Optimisations appliqu√©es"
}

# ========== SCRIPT DE LANCEMENT ULTIME ==========
create_ultimate_launcher() {
  log_header "CR√âATION DU LANCEUR ULTIME"
  
  cat > /usr/local/bin/shadow <<'EOF'
#!/bin/bash
# SHADOW LAUNCHER ULTIME - Raspberry Pi optimis√©

set -euo pipefail

GREEN='\033[0;32m'; YELLOW='\033[1;33m'; RED='\033[0;31m'; BLUE='\033[0;34m'; NC='\033[0m'

echo -e "${GREEN}"
echo "   _____ _               _                "
echo "  / ____| |             | |               "
echo " | (___ | |__   __ _  __| | _____      __ "
echo "  \___ \| '_ \ / _\` |/ _\` |/ _ \ \ /\ / / "
echo "  ____) | | | | (_| | (_| | (_) \ V  V /  "
echo " |_____/|_| |_|\__,_|\__,_|\___/ \_/\_/   "
echo "                                         "
echo -e "${NC}${BLUE}    RASPBERRY PI OPTIMIZED LAUNCHER      ${NC}"
echo

# Auto-diagnostic et r√©paration
auto_fix() {
  local fixed=0
  
  # D-Bus
  if [ -z "${DBUS_SESSION_BUS_ADDRESS:-}" ]; then
    echo -e "${YELLOW}üîß Configuration D-Bus...${NC}"
    export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u)/bus"
    if [ ! -S "/run/user/$(id -u)/bus" ]; then
      eval "$(dbus-launch --sh-syntax)" 2>/dev/null || true
    fi
    ((fixed++))
  fi
  
  # Notifications
  if ! pgrep -f "dunst|notification-daemon" >/dev/null 2>&1; then
    echo -e "${YELLOW}üîß D√©marrage des notifications...${NC}"
    (dunst >/dev/null 2>&1 &) || true
    sleep 2
    ((fixed++))
  fi
  
  # Variables d'environnement
  export XDG_CURRENT_DESKTOP="${XDG_CURRENT_DESKTOP:-LXDE}"
  export XDG_SESSION_TYPE="${XDG_SESSION_TYPE:-x11}"
  export LIBVA_DRIVER_NAME="${LIBVA_DRIVER_NAME:-v4l2_request}"
  export LIBVA_V4L2_REQUEST_VIDEO_PATH="${LIBVA_V4L2_REQUEST_VIDEO_PATH:-/dev/video10,/dev/video11,/dev/video12}"
  
  if [ $fixed -gt 0 ]; then
    echo -e "${GREEN}‚úÖ $fixed correction(s) appliqu√©e(s)${NC}"
  fi
}

# Options Shadow optimis√©es
SHADOW_OPTIONS=(
  "--disable-gpu-sandbox"
  "--use-gl=egl" 
  "--enable-features=VaapiVideoDecoder,VaapiVideoEncoder"
  "--disable-features=VizDisplayCompositor"
  "--enable-gpu-rasterization"
  "--enable-zero-copy"
  "--disable-background-timer-throttling"
  "--disable-backgrounding-occluded-windows"
  "--disable-renderer-backgrounding"
  "--disable-dev-shm-usage"
  "--no-sandbox"
)

main() {
  echo -e "${BLUE}üöÄ Initialisation...${NC}"
  auto_fix
  
  echo -e "${BLUE}üìä Informations syst√®me:${NC}"
  echo "  Desktop: $XDG_CURRENT_DESKTOP"
  echo "  Session: $XDG_SESSION_TYPE" 
  echo "  D-Bus: ${DBUS_SESSION_BUS_ADDRESS:-Non configur√©}"
  echo
  
  # Test de notification
  if command -v notify-send >/dev/null 2>&1; then
    notify-send "Shadow" "D√©marrage en cours..." 2>/dev/null || true
  fi
  
  echo -e "${GREEN}üéÆ Lancement de Shadow...${NC}"
  
  # D√©tection et lancement Shadow
  if command -v shadow-prod >/dev/null 2>&1; then
    echo -e "${GREEN}üì± shadow-prod d√©tect√©${NC}"
    exec shadow-prod "${SHADOW_OPTIONS[@]}" "$@"
  elif command -v shadow-beta >/dev/null 2>&1; then
    echo -e "${YELLOW}üì± shadow-beta d√©tect√©${NC}"
    exec shadow-beta "${SHADOW_OPTIONS[@]}" "$@"
  elif command -v shadow >/dev/null 2>&1; then
    echo -e "${GREEN}üì± shadow d√©tect√©${NC}"
    exec shadow "${SHADOW_OPTIONS[@]}" "$@"
  elif command -v flatpak >/dev/null 2>&1 && flatpak list | grep -q "com.shadow.BetaClient"; then
    echo -e "${BLUE}üì¶ Shadow Flatpak d√©tect√©${NC}"
    exec flatpak run com.shadow.BetaClient "$@"
  else
    echo -e "${RED}‚ùå Shadow non install√©!${NC}"
    echo "Utilisez: sudo bash shadow-ultimate.sh"
    exit 1
  fi
}

main "$@"
EOF

  chmod +x /usr/local/bin/shadow
  
  # Alias suppl√©mentaires
  ln -sf /usr/local/bin/shadow /usr/local/bin/shadow-optimized 2>/dev/null || true
  ln -sf /usr/local/bin/shadow /usr/local/bin/launch-shadow 2>/dev/null || true
  
  log_ok "Lanceur ultime cr√©√©: shadow"
}

# ========== TESTS FINAUX ==========
final_tests() {
  log_header "TESTS FINAUX"
  
  local all_good=true
  
  # Test binaires
  if command -v shadow-prod >/dev/null 2>&1 || command -v shadow >/dev/null 2>&1; then
    log_ok "Shadow PC: ‚úÖ"
  else
    log_err "Shadow PC: ‚ùå"
    all_good=false
  fi
  
  # Test ShadowUSB
  if systemctl is-enabled --quiet shadowusb.service 2>/dev/null; then
    log_ok "ShadowUSB: ‚úÖ"
  else
    log_warn "ShadowUSB: ‚ö†Ô∏è"
  fi
  
  # Test VS Code
  if command -v code >/dev/null 2>&1; then
    log_ok "VS Code: ‚úÖ"
  else
    log_warn "VS Code: ‚ö†Ô∏è"
  fi
  
  # Test notifications
  local user_home=$(get_user_home)
  if sudo -u "$SUDO_USER" DISPLAY=:0 notify-send "Test" "Syst√®me configur√©!" 2>/dev/null; then
    log_ok "Notifications: ‚úÖ"
  else
    log_warn "Notifications: ‚ö†Ô∏è (normal avant red√©marrage)"
  fi
  
  # Test lanceur
  if [ -x "/usr/local/bin/shadow" ]; then
    log_ok "Lanceur: ‚úÖ"
  else
    log_err "Lanceur: ‚ùå"
    all_good=false
  fi
  
  if $all_good; then
    log_ok "üéâ TOUT EST PARFAIT!"
  else
    log_warn "‚ö†Ô∏è Quelques √©l√©ments n√©cessitent attention"
  fi
}

# ========== RAPPORT FINAL ==========
show_final_report() {
  echo
  log_header "üèÅ INSTALLATION TERMIN√âE"
  
  echo -e "${GREEN}üéØ COMMANDES DISPONIBLES:${NC}"
  echo "  shadow                    ‚Üí Lance Shadow (optimis√©)"
  echo "  shadow-optimized          ‚Üí Alias du lanceur"
  echo "  code                      ‚Üí Lance VS Code"
  echo "  sudo systemctl status shadowusb ‚Üí √âtat ShadowUSB"
  echo
  
  echo -e "${BLUE}üìÅ FICHIERS CR√â√âS:${NC}"
  echo "  /usr/local/bin/shadow     ‚Üí Lanceur intelligent"
  echo "  ~/.xsessionrc             ‚Üí Configuration session"
  echo "  ~/.config/autostart/      ‚Üí D√©marrage automatique"
  echo
  
  echo -e "${YELLOW}‚ö†Ô∏è √âTAPES SUIVANTES:${NC}"
  echo "  1. Red√©marrer: sudo reboot"
  echo "  2. Lancer: shadow"
  echo "  3. Configurer Shadow (compte, etc.)"
  echo
  
  if grep -qi "raspberry pi 5" /proc/device-tree/model 2>/dev/null; then
    echo -e "${RED}üî• RASPBERRY PI 5 D√âTECT√â:${NC}"
    echo "  Le red√©marrage est OBLIGATOIRE (kernel 4K pages)"
  fi
  
  echo -e "${GREEN}‚ú® Profitez de Shadow sur votre Raspberry Pi! ‚ú®${NC}"
}

# ========== FONCTION PRINCIPALE ==========
main() {
  clear
  echo -e "${MAGENTA}"
  echo "‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà"
  echo "‚ñà                                                  ‚ñà"
  echo "‚ñà          SHADOW ULTIMATE INSTALLER              ‚ñà"
  echo "‚ñà         Raspberry Pi 4/5 - Tout-en-un          ‚ñà"
  echo "‚ñà                                                  ‚ñà"
  echo "‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà"
  echo -e "${NC}"
  
  require_root
  
  # Analyse syst√®me
  if ! system_analysis; then
    echo
    read -p "Continuer avec l'installation/r√©paration ? [O/n] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      log_warn "Installation annul√©e"
      exit 0
    fi
  else
    echo
    read -p "Syst√®me OK. Forcer la r√©installation ? [o/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[OoYy]$ ]]; then
      log_ok "Rien √† faire, syst√®me parfait!"
      exit 0
    fi
  fi
  
  # Ex√©cution s√©quentielle intelligente
  log_header "üöÄ D√âBUT DE L'INSTALLATION AUTOMATIQUE"
  
  system_update
  configure_raspberry_pi
  install_shadow
  install_shadowusb
  install_vscode
  setup_notifications
  setup_environment
  system_optimizations
  create_ultimate_launcher
  final_tests
  show_final_report
  
  echo
  log_ok "üéâ INSTALLATION ULTIMATE TERMIN√âE!"
  echo
}

# Point d'entr√©e
main "$@"